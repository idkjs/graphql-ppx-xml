diff --git a/node_modules/bs-node-fetch/examples/examples.ml b/node_modules/bs-node-fetch/examples/examples.ml
deleted file mode 100644
index 67388c8..0000000
--- a/node_modules/bs-node-fetch/examples/examples.ml
+++ /dev/null
@@ -1,21 +0,0 @@
-open Bs_node_fetch
-
-module Option = struct
-  let unwrapUnsafely = function
-    | Some v -> v
-    | None -> raise (Invalid_argument "unwrapUnsafely called on None");  
-end
-
-let _ =
-  Js.Promise.(
-    fetch "https://dog.ceo/api/breeds/list/all"
-    |> then_ Response.text
-    |> then_ (fun text -> print_endline text |> resolve)
-  )
-
-let _ =
-  Js.Promise.(
-    fetchWithInit "https://dog.ceo/api/breeds/list/all" (RequestInit.make ~method_:Post ())
-    |> then_ Response.text
-    |> then_ (fun text -> print_endline text |> resolve)
-  )
diff --git a/node_modules/bs-node-fetch/examples/examples.re b/node_modules/bs-node-fetch/examples/examples.re
new file mode 100644
index 0000000..2de05ff
--- /dev/null
+++ b/node_modules/bs-node-fetch/examples/examples.re
@@ -0,0 +1,20 @@
+open Bs_node_fetch;
+
+module Option = {
+  let unwrapUnsafely =
+    fun
+    | Some(v) => v
+    | None => raise(Invalid_argument("unwrapUnsafely called on None"));
+};
+
+Js.Promise.(
+  fetch("https://dog.ceo/api/breeds/list/all")
+  |> then_(Response.text)
+  |> then_((text) => print_endline(text) |> resolve)
+);
+
+Js.Promise.(
+  fetchWithInit("https://dog.ceo/api/breeds/list/all", RequestInit.make(~method_=Post, ()))
+  |> then_(Response.text)
+  |> then_((text) => print_endline(text) |> resolve)
+);
diff --git a/node_modules/bs-node-fetch/src/bs_node_fetch.ml b/node_modules/bs-node-fetch/src/bs_node_fetch.ml
deleted file mode 100644
index a9190c6..0000000
--- a/node_modules/bs-node-fetch/src/bs_node_fetch.ml
+++ /dev/null
@@ -1,374 +0,0 @@
-type body
-type bodyInit
-type headers
-type headersInit
-type response
-type request
-type requestInit
-
-(* external *)
-type arrayBuffer (* TypedArray *)
-type blob (* FileAPI *)
-type bufferSource (* Web IDL, either an arrayBuffer or arrayBufferView *)
-type formData (* XMLHttpRequest *)
-type readableStream (* Streams *)
-type urlSearchParams (* URL *)
-
-type requestMethod =
-  | Get
-  | Head
-  | Post
-  | Put
-  | Delete
-  | Connect
-  | Options
-  | Trace
-  | Patch
-  | Other of string
-let encodeRequestMethod = (* internal *)
-  function
-  | Get  -> "GET"
-  | Head  -> "HEAD"
-  | Post  -> "POST"
-  | Put  -> "PUT"
-  | Delete  -> "DELETE"
-  | Connect  -> "CONNECT"
-  | Options  -> "OPTIONS"
-  | Trace  -> "TRACE"
-  | Patch  -> "PATCH"
-  | Other method_ -> method_
-let decodeRequestMethod = (* internal *)
-  function
-  | "GET" -> Get
-  | "HEAD" -> Head
-  | "POST" -> Post
-  | "PUT" -> Put
-  | "DELETE" -> Delete
-  | "CONNECT" -> Connect
-  | "OPTIONS" -> Options
-  | "TRACE" -> Trace
-  | "PATCH" -> Patch
-  | method_ -> Other method_
-
-type referrerPolicy =
-  | None
-  | NoReferrer
-  | NoReferrerWhenDowngrade
-  | SameOrigin
-  | Origin
-  | StrictOrigin
-  | OriginWhenCrossOrigin
-  | StrictOriginWhenCrossOrigin
-  | UnsafeUrl
-let encodeReferrerPolicy = (* internal *)
-  function
-  | None  -> ""
-  | NoReferrer  -> "no-referrer"
-  | NoReferrerWhenDowngrade  -> "no-referrer-when-downgrade"
-  | SameOrigin  -> "same-origin"
-  | Origin  -> "origin"
-  | StrictOrigin  -> "strict-origin"
-  | OriginWhenCrossOrigin  -> "origin-when-cross-origin"
-  | StrictOriginWhenCrossOrigin  -> "strict-origin-when-cross-origin"
-  | UnsafeUrl  -> "unsafe-url"
-let decodeReferrerPolicy = (* internal *)
-  function
-  | "" -> None
-  | "no-referrer" -> NoReferrer
-  | "no-referrer-when-downgrade" -> NoReferrerWhenDowngrade
-  | "same-origin" -> SameOrigin
-  | "origin" -> Origin
-  | "strict-origin" -> StrictOrigin
-  | "origin-when-cross-origin" -> OriginWhenCrossOrigin
-  | "strict-origin-when-cross-origin" -> StrictOriginWhenCrossOrigin
-  | "unsafe-url" -> UnsafeUrl
-  | e -> raise (Failure ("Unknown referrerPolicy: " ^ e))
-
-type requestType =
-  | None (* default? unknown? just empty string in spec *)
-  | Audio
-  | Font
-  | Image
-  | Script
-  | Style
-  | Track
-  | Video
-let decodeRequestType = (* internal *)
-  function
-  | "" -> None
-  | "audio" -> Audio
-  | "font" -> Font
-  | "image" -> Image
-  | "script" -> Script
-  | "style" -> Style
-  | "track" -> Track
-  | "video" -> Video
-  | e -> raise (Failure ("Unknown requestType: " ^ e))
-
-type requestDestination =
-  | None (* default? unknown? just empty string in spec *)
-  | Document
-  | Embed
-  | Font
-  | Image
-  | Manifest
-  | Media
-  | Object
-  | Report
-  | Script
-  | ServiceWorker
-  | SharedWorker
-  | Style
-  | Worker
-  | Xslt
-let decodeRequestDestination = (* internal *)
-  function
-  | "" -> None
-  | "document" -> Document
-  | "embed" -> Embed
-  | "font" -> Font
-  | "image" -> Image
-  | "manifest" -> Manifest
-  | "media" -> Media
-  | "object" -> Object
-  | "report" -> Report
-  | "script" -> Script
-  | "serviceworker" -> ServiceWorker
-  | "sharedworder" -> SharedWorker
-  | "style" -> Style
-  | "worker" -> Worker
-  | "xslt" -> Xslt
-  | e -> raise (Failure ("Unknown requestDestination: " ^ e))
-
-type requestMode =
-  | Navigate
-  | SameOrigin
-  | NoCORS
-  | CORS
-let encodeRequestMode = (* internal *)
-  function
-  | Navigate  -> "navigate"
-  | SameOrigin  -> "same-origin"
-  | NoCORS  -> "no-cors"
-  | CORS  -> "cors"
-let decodeRequestMode = (* internaÃ¸ *)
-  function
-  | "navigate" -> Navigate
-  | "same-origin" -> SameOrigin
-  | "no-cors" -> NoCORS
-  | "cors" -> CORS
-  | e -> raise (Failure ("Unknown requestMode: " ^ e))
-
-type requestCredentials =
-  | Omit
-  | SameOrigin
-  | Include
-let encodeRequestCredentials = (* internal *)
-  function
-  | Omit  -> "omit"
-  | SameOrigin  -> "same-origin"
-  | Include  -> "include"
-let decodeRequestCredentials = (* internal *)
-  function
-  | "omit" -> Omit
-  | "same-origin" -> SameOrigin
-  | "imclude" -> Include
-  | e -> raise (Failure ("Unknown requestCredentials: " ^ e))
-
-type requestCache =
-  | Default
-  | NoStore
-  | Reload
-  | NoCache
-  | ForceCache
-  | OnlyIfCached
-let encodeRequestCache = (* internal *)
-  function
-  | Default  -> "default"
-  | NoStore  -> "no-store"
-  | Reload  -> "reload"
-  | NoCache  -> "no-cache"
-  | ForceCache  -> "force-cache"
-  | OnlyIfCached  -> "only-if-cached"
-let decodeRequestCache = (* internal *)
-  function
-  | "default" -> Default
-  | "no-store" -> NoStore
-  | "reload" -> Reload
-  | "no-cache" -> NoCache
-  | "force-cache" -> ForceCache
-  | "only-if-cached" -> OnlyIfCached
-  | e -> raise (Failure ("Unknown requestCache: " ^ e))
-
-type requestRedirect =
-  | Follow
-  | Error
-  | Manual
-let encodeRequestRedirect = (* internal *)
-  function
-  | Follow  -> "follow"
-  | Error  -> "error"
-  | Manual  -> "manual"
-let decodeRequestRedirect = (* internal *)
-  function
-  | "follow" -> Follow
-  | "error" -> Error
-  | "manual" -> Manual
-  | e -> raise (Failure ("Unknown requestRedirect: " ^ e))
-
-module HeadersInit = struct
-  type t = headersInit
-
-  external make : < .. > Js.t -> t = "%identity"
-  external makeWithArray : (string * string) array -> t = "%identity"
-end
-
-module Headers = struct
-  type t = headers
-
-  external make : t = "Headers" [@@bs.new]
-  external makeWithInit : headersInit -> t = "Headers" [@@bs.new]
-
-  external append : string -> string = "" [@@bs.send.pipe: t]
-  external delete : string = "" [@@bs.send.pipe: t]
-  (* entries *) (* very experimental *)
-  external get : string -> string option = "" [@@bs.send.pipe: t] [@@bs.return {null_to_opt}]
-  external has : string -> bool = "" [@@bs.send.pipe: t]
-  (* keys *) (* very experimental *)
-  external set : string -> string -> unit = "" [@@bs.send.pipe: t]
-  (* values *) (* very experimental *)
-end
-
-module BodyInit = struct
-  type t = bodyInit
-
-  external make : string -> t = "%identity"
-  external makeWithBlob : blob -> t = "%identity"
-  external makeWithBufferSource : bufferSource -> t = "%identity"
-  external makeWithFormData : formData -> t = "%identity"
-  external makeWithUrlSearchParams : urlSearchParams -> t = "%identity"
-end
-
-module Body = struct
-  module Impl(T: sig type t end) = struct
-    external body : T.t -> readableStream = "" [@@bs.get]
-    external bodyUsed : T.t -> bool = "" [@@bs.get]
-
-    external arrayBuffer : arrayBuffer Js.Promise.t = "" [@@bs.send.pipe: T.t]
-    external blob : blob Js.Promise.t = "" [@@bs.send.pipe: T.t]
-    external formData : formData Js.Promise.t = "" [@@bs.send.pipe: T.t]
-    external json : Js.Json.t Js.Promise.t = "" [@@bs.send.pipe: T.t]
-    external text : string Js.Promise.t = "" [@@bs.send.pipe: T.t]
-  end
-
-  type t = body
-  include Impl(struct type nonrec t = t end)
-end
-
-module RequestInit = struct
-  type t = requestInit
-
-  let map f = function (* internal *)
-  | Some v -> Some (f v)
-  | None  -> None
-
-  external make :
-    ?_method:string ->
-    ?headers:headersInit ->
-    ?body:bodyInit ->
-    ?referrer:string ->
-    ?referrerPolicy:string ->
-    ?mode:string ->
-    ?credentials:string ->
-    ?cache:string ->
-    ?redirect:string ->
-    ?integrity:string ->
-    ?keepalive:bool ->
-    ?timeout: int ->
-    unit -> requestInit = "" [@@bs.obj]
-  let make
-    ?method_:(method_: requestMethod option)
-    ?headers:(headers: headersInit option)
-    ?body:(body: bodyInit option)
-    ?referrer:(referrer: string option)
-    ?referrerPolicy:(referrerPolicy: referrerPolicy = None)
-    ?mode:(mode: requestMode option)
-    ?credentials:(credentials: requestCredentials option)
-    ?cache:(cache: requestCache option)
-    ?redirect:(redirect: requestRedirect option)
-    ?integrity:(integrity: string = "")
-    ?keepalive:(keepalive: bool option)
-    ?timeout:(timeout: int option)
-    = make
-        ?_method: (map encodeRequestMethod method_)
-        ?headers
-        ?body
-        ?referrer
-        ~referrerPolicy: (encodeReferrerPolicy referrerPolicy)
-        ?mode: (map encodeRequestMode mode)
-        ?credentials: (map encodeRequestCredentials credentials)
-        ?cache: (map encodeRequestCache cache)
-        ?redirect: (map encodeRequestRedirect redirect)
-        ~integrity
-        ?keepalive
-        ?timeout
-end
-
-module Request = struct
-  type t = request
-
-  include Body.Impl(struct type nonrec t = t end)
-
-  external make : string -> t = "Request" [@@bs.new]
-  external makeWithInit : string -> requestInit -> t = "Request" [@@bs.new]
-  external makeWithRequest : t -> t = "Request" [@@bs.new]
-  external makeWithRequestInit : t -> requestInit -> t = "Request" [@@bs.new]
-
-  external method_ : t -> string = "method" [@@bs.get]
-  let method_: t -> requestMethod = fun self -> decodeRequestMethod (method_ self)
-  external url : t -> string = ""[@@bs.get]
-  external headers : t -> headers = "" [@@bs.get]
-  external type_ : t -> string = "type" [@@bs.get]
-  let type_: t -> requestType = fun self -> decodeRequestType (type_ self)
-  external destination : t -> string = "" [@@bs.get]
-  let destination: t -> requestDestination = fun self -> decodeRequestDestination (destination self)
-  external referrer : t -> string = "" [@@bs.get]
-  external referrerPolicy : t -> string = "" [@@bs.get]
-  let referrerPolicy: t -> referrerPolicy = fun self -> decodeReferrerPolicy (referrerPolicy self)
-  external mode : t -> string = "" [@@bs.get]
-  let mode: t -> requestMode = fun self  -> decodeRequestMode (mode self)
-  external credentials : t -> string = "" [@@bs.get]
-  let credentials: t -> requestCredentials = fun self -> decodeRequestCredentials (credentials self)
-  external cache : t -> string = "" [@@bs.get]
-  let cache: t -> requestCache = fun self -> decodeRequestCache (cache self)
-  external redirect : t -> string = "" [@@bs.get]
-  let redirect: t -> requestRedirect = fun self -> decodeRequestRedirect (redirect self)
-  external integrity : t -> string = "" [@@bs.get]
-  external keepalive : t -> bool = "" [@@bs.get]
-  external timeout: t -> int = "" [@@bs.get]
-end
-
-module Response = struct
-  type t = response
-
-  include Body.Impl(struct type nonrec t = t end)
-
-  external error : unit -> t = "" [@@bs.val]
-  external redirect : string -> t = "" [@@bs.val]
-  external redirectWithStatus : string -> int (* enum-ish *) -> t = "redirect" [@@bs.val]
-  external headers : t -> headers = "" [@@bs.get]
-  external ok : t -> bool = "" [@@bs.get]
-  external redirected : t -> bool = "" [@@bs.get]
-  external status : t -> int = "" [@@bs.get]
-  external statusText : t -> string = "" [@@bs.get]
-  external _type : t -> string = "" [@@bs.get]
-  external url : t -> string = "" [@@bs.get]
-
-  external clone : t = "" [@@bs.send.pipe: t]
-end
-
-
-external fetch : string -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
-external fetchWithInit : string -> requestInit -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
-external fetchWithRequest : request -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
-external fetchWithRequestInit : request -> requestInit -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
diff --git a/node_modules/bs-node-fetch/src/bs_node_fetch.mli b/node_modules/bs-node-fetch/src/bs_node_fetch.mli
deleted file mode 100644
index 8c22199..0000000
--- a/node_modules/bs-node-fetch/src/bs_node_fetch.mli
+++ /dev/null
@@ -1,220 +0,0 @@
-type body
-type bodyInit
-type headers
-type headersInit
-type response
-type request
-type requestInit
-
-(* external *)
-type arrayBuffer (* TypedArray *)
-type blob (* FileAPI *)
-type bufferSource (* Web IDL, either an arrayBuffer or arrayBufferView *)
-type formData (* XMLHttpRequest *)
-type readableStream (* Streams *)
-type urlSearchParams (* URL *)
-
-type requestMethod =
-  | Get
-  | Head
-  | Post
-  | Put
-  | Delete
-  | Connect
-  | Options
-  | Trace
-  | Patch
-  | Other of string
-
-type referrerPolicy =
-  | None
-  | NoReferrer
-  | NoReferrerWhenDowngrade
-  | SameOrigin
-  | Origin
-  | StrictOrigin
-  | OriginWhenCrossOrigin
-  | StrictOriginWhenCrossOrigin
-  | UnsafeUrl
-
-type requestType =
-  | None (* default? unknown? just empty string in spec *)
-  | Audio
-  | Font
-  | Image
-  | Script
-  | Style
-  | Track
-  | Video
-
-type requestDestination =
-  | None (* default? unknown? just empty string in spec *)
-  | Document
-  | Embed
-  | Font
-  | Image
-  | Manifest
-  | Media
-  | Object
-  | Report
-  | Script
-  | ServiceWorker
-  | SharedWorker
-  | Style
-  | Worker
-  | Xslt
-
-type requestMode =
-  | Navigate
-  | SameOrigin
-  | NoCORS
-  | CORS
-
-type requestCredentials =
-  | Omit
-  | SameOrigin
-  | Include
-
-type requestCache =
-  | Default
-  | NoStore
-  | Reload
-  | NoCache
-  | ForceCache
-  | OnlyIfCached
-
-type requestRedirect =
-  | Follow
-  | Error
-  | Manual
-
-module HeadersInit : sig
-  type t = headersInit
-
-  external make : < .. > Js.t -> t = "%identity"
-  external makeWithArray : (string * string) array -> t = "%identity"
-end
-
-module Headers : sig
-  type t = headers
-
-  external make : t = "Headers" [@@bs.new]
-  external makeWithInit : headersInit -> t = "Headers" [@@bs.new]
-
-  external append : string -> string = "" [@@bs.send.pipe: t]
-  external delete : string = "" [@@bs.send.pipe: t]
-  (* entries *) (* very experimental *)
-  external get : string -> string option = "" [@@bs.send.pipe: t] [@@bs.return {null_to_opt}]
-  external has : string -> bool = "" [@@bs.send.pipe: t]
-  (* keys *) (* very experimental *)
-  external set : string -> string -> unit = "" [@@bs.send.pipe: t]
-  (* values *) (* very experimental *)
-end
-
-module BodyInit : sig
-  type t = bodyInit
-
-  external make : string -> t = "%identity"
-  external makeWithBlob : blob -> t = "%identity"
-  external makeWithBufferSource : bufferSource -> t = "%identity"
-  external makeWithFormData : formData -> t = "%identity"
-  external makeWithUrlSearchParams : urlSearchParams -> t = "%identity"
-end
-
-module Body : sig
-  type t = body
-
-  external body : t -> readableStream = "" [@@bs.get]
-  external bodyUsed : t -> bool = "" [@@bs.get]
-
-  external arrayBuffer : arrayBuffer Js.Promise.t = "" [@@bs.send.pipe: t]
-  external blob : blob Js.Promise.t = "" [@@bs.send.pipe: t]
-  external formData : formData Js.Promise.t = "" [@@bs.send.pipe: t]
-  external json : Js.Json.t Js.Promise.t = "" [@@bs.send.pipe: t]
-  external text : string Js.Promise.t = "" [@@bs.send.pipe: t]
-end
-
-module RequestInit : sig
-  type t = requestInit
-
-  val make :
-    ?method_:requestMethod ->
-    ?headers:headersInit ->
-    ?body:bodyInit ->
-    ?referrer:string ->
-    ?referrerPolicy:referrerPolicy ->
-    ?mode:requestMode ->
-    ?credentials:requestCredentials ->
-    ?cache:requestCache ->
-    ?redirect:requestRedirect ->
-    ?integrity:string ->
-    ?keepalive:bool ->
-    ?timeout: int ->
-    unit -> t
-end
-
-module Request : sig
-  type t = request
-
-  external make : string -> t = "Request" [@@bs.new]
-  external makeWithInit : string -> requestInit -> t = "Request" [@@bs.new]
-  external makeWithRequest : t -> t = "Request" [@@bs.new]
-  external makeWithRequestInit : t -> requestInit -> t = "Request" [@@bs.new]
-
-  val method_: t -> requestMethod
-  external url : t -> string = ""[@@bs.get]
-  external headers : t -> headers = "" [@@bs.get]
-  val type_: t -> requestType
-  val destination: t -> requestDestination
-  external referrer : t -> string = "" [@@bs.get]
-  val referrerPolicy: t -> referrerPolicy
-  val mode: t -> requestMode
-  val credentials: t -> requestCredentials
-  val cache: t -> requestCache
-  val redirect: t -> requestRedirect
-  external integrity : t -> string = "" [@@bs.get]
-  external keepalive : t -> bool = "" [@@bs.get]
-  external timeout : t -> int = "" [@@bs.get]
-
-  (* Body Impl *)
-  external body : t -> readableStream = "" [@@bs.get]
-  external bodyUsed : t -> bool = "" [@@bs.get]
-
-  external arrayBuffer : arrayBuffer Js.Promise.t = "" [@@bs.send.pipe: t]
-  external blob : blob Js.Promise.t = "" [@@bs.send.pipe: t]
-  external formData : formData Js.Promise.t = "" [@@bs.send.pipe: t]
-  external json : Js.Json.t Js.Promise.t = "" [@@bs.send.pipe: t]
-  external text : string Js.Promise.t = "" [@@bs.send.pipe: t]
-end
-
-module Response : sig
-  type t = response
-
-  external error : unit -> t = "" [@@bs.val]
-  external redirect : string -> t = "" [@@bs.val]
-  external redirectWithStatus : string -> int (* enum-ish *) -> t = "redirect" [@@bs.val]
-  external headers : t -> headers = "" [@@bs.get]
-  external ok : t -> bool = "" [@@bs.get]
-  external redirected : t -> bool = "" [@@bs.get]
-  external status : t -> int = "" [@@bs.get]
-  external statusText : t -> string = "" [@@bs.get]
-  external _type : t -> string = "" [@@bs.get]
-  external url : t -> string = "" [@@bs.get]
-
-  external clone : t = "" [@@bs.send.pipe: t]
-
-  (* Body.Impl *)
-  external body : t -> readableStream = "" [@@bs.get]
-  external bodyUsed : t -> bool = "" [@@bs.get]
-
-  external arrayBuffer : arrayBuffer Js.Promise.t = "" [@@bs.send.pipe: t]
-  external blob : blob Js.Promise.t = "" [@@bs.send.pipe: t]
-  external formData : formData Js.Promise.t = "" [@@bs.send.pipe: t]
-  external json : Js.Json.t Js.Promise.t = "" [@@bs.send.pipe: t]
-  external text : string Js.Promise.t = "" [@@bs.send.pipe: t]
-end
-
-external fetch : string -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
-external fetchWithInit : string -> requestInit -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
-external fetchWithRequest : request -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
-external fetchWithRequestInit : request -> requestInit -> response Js.Promise.t = "default" [@@bs.module "node-fetch"]
diff --git a/node_modules/bs-node-fetch/src/bs_node_fetch.re b/node_modules/bs-node-fetch/src/bs_node_fetch.re
new file mode 100644
index 0000000..c6f180d
--- /dev/null
+++ b/node_modules/bs-node-fetch/src/bs_node_fetch.re
@@ -0,0 +1,426 @@
+type body;
+
+type bodyInit;
+
+type headers;
+
+type headersInit;
+
+type response;
+
+type request;
+
+type requestInit;
+
+/* external */
+type arrayBuffer; /* TypedArray */
+
+type blob; /* FileAPI */
+
+type bufferSource; /* Web IDL, either an arrayBuffer or arrayBufferView */
+
+type formData; /* XMLHttpRequest */
+
+type readableStream; /* Streams */
+
+type urlSearchParams; /* URL */
+
+type requestMethod =
+  | Get
+  | Head
+  | Post
+  | Put
+  | Delete
+  | Connect
+  | Options
+  | Trace
+  | Patch
+  | Other(string);
+
+let encodeRequestMethod =
+  /* internal */
+  fun
+  | Get => "GET"
+  | Head => "HEAD"
+  | Post => "POST"
+  | Put => "PUT"
+  | Delete => "DELETE"
+  | Connect => "CONNECT"
+  | Options => "OPTIONS"
+  | Trace => "TRACE"
+  | Patch => "PATCH"
+  | Other(method) => method;
+
+let decodeRequestMethod =
+  /* internal */
+  fun
+  | "GET" => Get
+  | "HEAD" => Head
+  | "POST" => Post
+  | "PUT" => Put
+  | "DELETE" => Delete
+  | "CONNECT" => Connect
+  | "OPTIONS" => Options
+  | "TRACE" => Trace
+  | "PATCH" => Patch
+  | method => Other(method);
+
+type referrerPolicy =
+  | None
+  | NoReferrer
+  | NoReferrerWhenDowngrade
+  | SameOrigin
+  | Origin
+  | StrictOrigin
+  | OriginWhenCrossOrigin
+  | StrictOriginWhenCrossOrigin
+  | UnsafeUrl;
+
+let encodeReferrerPolicy =
+  /* internal */
+  fun
+  | None => ""
+  | NoReferrer => "no-referrer"
+  | NoReferrerWhenDowngrade => "no-referrer-when-downgrade"
+  | SameOrigin => "same-origin"
+  | Origin => "origin"
+  | StrictOrigin => "strict-origin"
+  | OriginWhenCrossOrigin => "origin-when-cross-origin"
+  | StrictOriginWhenCrossOrigin => "strict-origin-when-cross-origin"
+  | UnsafeUrl => "unsafe-url";
+
+let decodeReferrerPolicy =
+  /* internal */
+  fun
+  | "" => None
+  | "no-referrer" => NoReferrer
+  | "no-referrer-when-downgrade" => NoReferrerWhenDowngrade
+  | "same-origin" => SameOrigin
+  | "origin" => Origin
+  | "strict-origin" => StrictOrigin
+  | "origin-when-cross-origin" => OriginWhenCrossOrigin
+  | "strict-origin-when-cross-origin" => StrictOriginWhenCrossOrigin
+  | "unsafe-url" => UnsafeUrl
+  | e => raise(Failure("Unknown referrerPolicy: " ++ e));
+
+type requestType =
+  | None /* default? unknown? just empty string in spec */
+  | Audio
+  | Font
+  | Image
+  | Script
+  | Style
+  | Track
+  | Video;
+
+let decodeRequestType =
+  /* internal */
+  fun
+  | "" => None
+  | "audio" => Audio
+  | "font" => Font
+  | "image" => Image
+  | "script" => Script
+  | "style" => Style
+  | "track" => Track
+  | "video" => Video
+  | e => raise(Failure("Unknown requestType: " ++ e));
+
+type requestDestination =
+  | None /* default? unknown? just empty string in spec */
+  | Document
+  | Embed
+  | Font
+  | Image
+  | Manifest
+  | Media
+  | Object
+  | Report
+  | Script
+  | ServiceWorker
+  | SharedWorker
+  | Style
+  | Worker
+  | Xslt;
+
+let decodeRequestDestination =
+  /* internal */
+  fun
+  | "" => None
+  | "document" => Document
+  | "embed" => Embed
+  | "font" => Font
+  | "image" => Image
+  | "manifest" => Manifest
+  | "media" => Media
+  | "object" => Object
+  | "report" => Report
+  | "script" => Script
+  | "serviceworker" => ServiceWorker
+  | "sharedworder" => SharedWorker
+  | "style" => Style
+  | "worker" => Worker
+  | "xslt" => Xslt
+  | e => raise(Failure("Unknown requestDestination: " ++ e));
+
+type requestMode =
+  | Navigate
+  | SameOrigin
+  | NoCORS
+  | CORS;
+
+let encodeRequestMode =
+  /* internal */
+  fun
+  | Navigate => "navigate"
+  | SameOrigin => "same-origin"
+  | NoCORS => "no-cors"
+  | CORS => "cors";
+
+let decodeRequestMode =
+  /* interna  */
+  fun
+  | "navigate" => Navigate
+  | "same-origin" => SameOrigin
+  | "no-cors" => NoCORS
+  | "cors" => CORS
+  | e => raise(Failure("Unknown requestMode: " ++ e));
+
+type requestCredentials =
+  | Omit
+  | SameOrigin
+  | Include;
+
+let encodeRequestCredentials =
+  /* internal */
+  fun
+  | Omit => "omit"
+  | SameOrigin => "same-origin"
+  | Include => "include";
+
+let decodeRequestCredentials =
+  /* internal */
+  fun
+  | "omit" => Omit
+  | "same-origin" => SameOrigin
+  | "imclude" => Include
+  | e => raise(Failure("Unknown requestCredentials: " ++ e));
+
+type requestCache =
+  | Default
+  | NoStore
+  | Reload
+  | NoCache
+  | ForceCache
+  | OnlyIfCached;
+
+let encodeRequestCache =
+  /* internal */
+  fun
+  | Default => "default"
+  | NoStore => "no-store"
+  | Reload => "reload"
+  | NoCache => "no-cache"
+  | ForceCache => "force-cache"
+  | OnlyIfCached => "only-if-cached";
+
+let decodeRequestCache =
+  /* internal */
+  fun
+  | "default" => Default
+  | "no-store" => NoStore
+  | "reload" => Reload
+  | "no-cache" => NoCache
+  | "force-cache" => ForceCache
+  | "only-if-cached" => OnlyIfCached
+  | e => raise(Failure("Unknown requestCache: " ++ e));
+
+type requestRedirect =
+  | Follow
+  | Error
+  | Manual;
+
+let encodeRequestRedirect =
+  /* internal */
+  fun
+  | Follow => "follow"
+  | Error => "error"
+  | Manual => "manual";
+
+let decodeRequestRedirect =
+  /* internal */
+  fun
+  | "follow" => Follow
+  | "error" => Error
+  | "manual" => Manual
+  | e => raise(Failure("Unknown requestRedirect: " ++ e));
+
+module HeadersInit = {
+  type t = headersInit;
+  external make : Js.t({..}) => t = "%identity";
+  external makeWithArray : array((string, string)) => t = "%identity";
+};
+
+module Headers = {
+  type t = headers;
+  [@bs.new] external make : t = "Headers";
+  [@bs.new] external makeWithInit : headersInit => t = "Headers";
+  [@bs.send.pipe : t] external append : string => string = "";
+  [@bs.send.pipe : t] external delete : string = "" /* very experimental */; /* entries */
+  [@bs.send.pipe : t] [@bs.return {null_to_opt: null_to_opt}]
+  external get : string => option(string) = "";
+  [@bs.send.pipe : t] external has : string => bool = "" /* very experimental */; /* keys */
+  [@bs.send.pipe : t] external set : (string, string) => unit = "" /* very experimental */; /* values */
+};
+
+module BodyInit = {
+  type t = bodyInit;
+  external make : string => t = "%identity";
+  external makeWithBlob : blob => t = "%identity";
+  external makeWithBufferSource : bufferSource => t = "%identity";
+  external makeWithFormData : formData => t = "%identity";
+  external makeWithUrlSearchParams : urlSearchParams => t = "%identity";
+};
+
+module Body = {
+  module Impl = (T: {type t;}) => {
+    [@bs.get] external body : T.t => readableStream = "";
+    [@bs.get] external bodyUsed : T.t => bool = "";
+    [@bs.send.pipe : T.t] external arrayBuffer : Js.Promise.t(arrayBuffer) = "";
+    [@bs.send.pipe : T.t] external blob : Js.Promise.t(blob) = "";
+    [@bs.send.pipe : T.t] external formData : Js.Promise.t(formData) = "";
+    [@bs.send.pipe : T.t] external json : Js.Promise.t(Js.Json.t) = "";
+    [@bs.send.pipe : T.t] external text : Js.Promise.t(string) = "";
+  };
+  type t = body;
+  include
+    Impl(
+      {
+        type nonrec t = t;
+      }
+    );
+};
+
+module RequestInit = {
+  type t = requestInit;
+  let map = (f) =>
+    fun /* internal */
+    | Some(v) => Some(f(v))
+    | None => None;
+  [@bs.obj]
+  external make :
+    (
+      ~_method: string=?,
+      ~headers: headersInit=?,
+      ~body: bodyInit=?,
+      ~referrer: string=?,
+      ~referrerPolicy: string=?,
+      ~mode: string=?,
+      ~credentials: string=?,
+      ~cache: string=?,
+      ~redirect: string=?,
+      ~integrity: string=?,
+      ~keepalive: bool=?,
+      ~timeout: int=?,
+      unit
+    ) =>
+    requestInit =
+    "";
+  let make =
+      (
+        ~method_ as method: option(requestMethod)=?,
+        ~headers: option(headersInit)=?,
+        ~body: option(bodyInit)=?,
+        ~referrer: option(string)=?,
+        ~referrerPolicy: referrerPolicy=None,
+        ~mode: option(requestMode)=?,
+        ~credentials: option(requestCredentials)=?,
+        ~cache: option(requestCache)=?,
+        ~redirect: option(requestRedirect)=?,
+        ~integrity: string="",
+        ~keepalive: option(bool)=?,
+        ~timeout: option(int)=?
+      ) =>
+    make(
+      ~_method=?map(encodeRequestMethod, method),
+      ~headers?,
+      ~body?,
+      ~referrer?,
+      ~referrerPolicy=encodeReferrerPolicy(referrerPolicy),
+      ~mode=?map(encodeRequestMode, mode),
+      ~credentials=?map(encodeRequestCredentials, credentials),
+      ~cache=?map(encodeRequestCache, cache),
+      ~redirect=?map(encodeRequestRedirect, redirect),
+      ~integrity,
+      ~keepalive?,
+      ~timeout?
+    );
+};
+
+module Request = {
+  type t = request;
+  include
+    Body.Impl(
+      {
+        type nonrec t = t;
+      }
+    );
+  [@bs.new] external make : string => t = "Request";
+  [@bs.new] external makeWithInit : (string, requestInit) => t = "Request";
+  [@bs.new] external makeWithRequest : t => t = "Request";
+  [@bs.new] external makeWithRequestInit : (t, requestInit) => t = "Request";
+  [@bs.get] external method_ : t => string = "method";
+  let method: t => requestMethod = (self) => decodeRequestMethod(method_(self));
+  [@bs.get] external url : t => string = "";
+  [@bs.get] external headers : t => headers = "";
+  [@bs.get] external type_ : t => string = "type";
+  let type_: t => requestType = (self) => decodeRequestType(type_(self));
+  [@bs.get] external destination : t => string = "";
+  let destination: t => requestDestination = (self) => decodeRequestDestination(destination(self));
+  [@bs.get] external referrer : t => string = "";
+  [@bs.get] external referrerPolicy : t => string = "";
+  let referrerPolicy: t => referrerPolicy = (self) => decodeReferrerPolicy(referrerPolicy(self));
+  [@bs.get] external mode : t => string = "";
+  let mode: t => requestMode = (self) => decodeRequestMode(mode(self));
+  [@bs.get] external credentials : t => string = "";
+  let credentials: t => requestCredentials = (self) => decodeRequestCredentials(credentials(self));
+  [@bs.get] external cache : t => string = "";
+  let cache: t => requestCache = (self) => decodeRequestCache(cache(self));
+  [@bs.get] external redirect : t => string = "";
+  let redirect: t => requestRedirect = (self) => decodeRequestRedirect(redirect(self));
+  [@bs.get] external integrity : t => string = "";
+  [@bs.get] external keepalive : t => bool = "";
+  [@bs.get] external timeout : t => int = "";
+};
+
+module Response = {
+  type t = response;
+  include
+    Body.Impl(
+      {
+        type nonrec t = t;
+      }
+    );
+  [@bs.val] external error : unit => t = "";
+  [@bs.val] external redirect : string => t = "";
+  [@bs.val] external redirectWithStatus : (string, int /* enum-ish */) => t = "redirect";
+  [@bs.get] external headers : t => headers = "";
+  [@bs.get] external ok : t => bool = "";
+  [@bs.get] external redirected : t => bool = "";
+  [@bs.get] external status : t => int = "";
+  [@bs.get] external statusText : t => string = "";
+  [@bs.get] external _type : t => string = "";
+  [@bs.get] external url : t => string = "";
+  [@bs.send.pipe : t] external clone : t = "";
+};
+
+[@bs.module "node-fetch"] external fetch : string => Js.Promise.t(response) = "default";
+
+[@bs.module "node-fetch"]
+external fetchWithInit : (string, requestInit) => Js.Promise.t(response) = "default";
+
+[@bs.module "node-fetch"]
+external fetchWithRequest : request => Js.Promise.t(response) = "default";
+
+[@bs.module "node-fetch"]
+external fetchWithRequestInit : (request, requestInit) => Js.Promise.t(response) = "default";
diff --git a/node_modules/bs-node-fetch/src/bs_node_fetch.rei b/node_modules/bs-node-fetch/src/bs_node_fetch.rei
new file mode 100644
index 0000000..b487249
--- /dev/null
+++ b/node_modules/bs-node-fetch/src/bs_node_fetch.rei
@@ -0,0 +1,223 @@
+type body;
+
+type bodyInit;
+
+type headers;
+
+type headersInit;
+
+type response;
+
+type request;
+
+type requestInit;
+
+/* external */
+type arrayBuffer; /* TypedArray */
+
+type blob; /* FileAPI */
+
+type bufferSource; /* Web IDL, either an arrayBuffer or arrayBufferView */
+
+type formData; /* XMLHttpRequest */
+
+type readableStream; /* Streams */
+
+type urlSearchParams; /* URL */
+
+type requestMethod =
+  | Get
+  | Head
+  | Post
+  | Put
+  | Delete
+  | Connect
+  | Options
+  | Trace
+  | Patch
+  | Other(string);
+
+type referrerPolicy =
+  | None
+  | NoReferrer
+  | NoReferrerWhenDowngrade
+  | SameOrigin
+  | Origin
+  | StrictOrigin
+  | OriginWhenCrossOrigin
+  | StrictOriginWhenCrossOrigin
+  | UnsafeUrl;
+
+type requestType =
+  | None /* default? unknown? just empty string in spec */
+  | Audio
+  | Font
+  | Image
+  | Script
+  | Style
+  | Track
+  | Video;
+
+type requestDestination =
+  | None /* default? unknown? just empty string in spec */
+  | Document
+  | Embed
+  | Font
+  | Image
+  | Manifest
+  | Media
+  | Object
+  | Report
+  | Script
+  | ServiceWorker
+  | SharedWorker
+  | Style
+  | Worker
+  | Xslt;
+
+type requestMode =
+  | Navigate
+  | SameOrigin
+  | NoCORS
+  | CORS;
+
+type requestCredentials =
+  | Omit
+  | SameOrigin
+  | Include;
+
+type requestCache =
+  | Default
+  | NoStore
+  | Reload
+  | NoCache
+  | ForceCache
+  | OnlyIfCached;
+
+type requestRedirect =
+  | Follow
+  | Error
+  | Manual;
+
+module HeadersInit: {
+  type t = headersInit;
+  external make : Js.t({..}) => t = "%identity";
+  external makeWithArray : array((string, string)) => t = "%identity";
+};
+
+module Headers: {
+  type t = headers;
+  [@bs.new] external make : t = "Headers";
+  [@bs.new] external makeWithInit : headersInit => t = "Headers";
+  [@bs.send.pipe : t] external append : string => string = "";
+  [@bs.send.pipe : t] external delete : string = "" /* very experimental */; /* entries */
+  [@bs.send.pipe : t] [@bs.return {null_to_opt: null_to_opt}]
+  external get : string => option(string) = "";
+  [@bs.send.pipe : t] external has : string => bool = "" /* very experimental */; /* keys */
+  [@bs.send.pipe : t] external set : (string, string) => unit = "" /* very experimental */; /* values */
+};
+
+module BodyInit: {
+  type t = bodyInit;
+  external make : string => t = "%identity";
+  external makeWithBlob : blob => t = "%identity";
+  external makeWithBufferSource : bufferSource => t = "%identity";
+  external makeWithFormData : formData => t = "%identity";
+  external makeWithUrlSearchParams : urlSearchParams => t = "%identity";
+};
+
+module Body: {
+  type t = body;
+  [@bs.get] external body : t => readableStream = "";
+  [@bs.get] external bodyUsed : t => bool = "";
+  [@bs.send.pipe : t] external arrayBuffer : Js.Promise.t(arrayBuffer) = "";
+  [@bs.send.pipe : t] external blob : Js.Promise.t(blob) = "";
+  [@bs.send.pipe : t] external formData : Js.Promise.t(formData) = "";
+  [@bs.send.pipe : t] external json : Js.Promise.t(Js.Json.t) = "";
+  [@bs.send.pipe : t] external text : Js.Promise.t(string) = "";
+};
+
+module RequestInit: {
+  type t = requestInit;
+  let make:
+    (
+      ~method_: requestMethod=?,
+      ~headers: headersInit=?,
+      ~body: bodyInit=?,
+      ~referrer: string=?,
+      ~referrerPolicy: referrerPolicy=?,
+      ~mode: requestMode=?,
+      ~credentials: requestCredentials=?,
+      ~cache: requestCache=?,
+      ~redirect: requestRedirect=?,
+      ~integrity: string=?,
+      ~keepalive: bool=?,
+      ~timeout: int=?,
+      unit
+    ) =>
+    t;
+};
+
+module Request: {
+  type t = request;
+  [@bs.new] external make : string => t = "Request";
+  [@bs.new] external makeWithInit : (string, requestInit) => t = "Request";
+  [@bs.new] external makeWithRequest : t => t = "Request";
+  [@bs.new] external makeWithRequestInit : (t, requestInit) => t = "Request";
+  let method: t => requestMethod;
+  [@bs.get] external url : t => string = "";
+  [@bs.get] external headers : t => headers = "";
+  let type_: t => requestType;
+  let destination: t => requestDestination;
+  [@bs.get] external referrer : t => string = "";
+  let referrerPolicy: t => referrerPolicy;
+  let mode: t => requestMode;
+  let credentials: t => requestCredentials;
+  let cache: t => requestCache;
+  let redirect: t => requestRedirect;
+  [@bs.get] external integrity : t => string = "";
+  [@bs.get] external keepalive : t => bool = "";
+  [@bs.get] external timeout : t => int = "";
+  /* Body Impl */
+  [@bs.get] external body : t => readableStream = "";
+  [@bs.get] external bodyUsed : t => bool = "";
+  [@bs.send.pipe : t] external arrayBuffer : Js.Promise.t(arrayBuffer) = "";
+  [@bs.send.pipe : t] external blob : Js.Promise.t(blob) = "";
+  [@bs.send.pipe : t] external formData : Js.Promise.t(formData) = "";
+  [@bs.send.pipe : t] external json : Js.Promise.t(Js.Json.t) = "";
+  [@bs.send.pipe : t] external text : Js.Promise.t(string) = "";
+};
+
+module Response: {
+  type t = response;
+  [@bs.val] external error : unit => t = "";
+  [@bs.val] external redirect : string => t = "";
+  [@bs.val] external redirectWithStatus : (string, int /* enum-ish */) => t = "redirect";
+  [@bs.get] external headers : t => headers = "";
+  [@bs.get] external ok : t => bool = "";
+  [@bs.get] external redirected : t => bool = "";
+  [@bs.get] external status : t => int = "";
+  [@bs.get] external statusText : t => string = "";
+  [@bs.get] external _type : t => string = "";
+  [@bs.get] external url : t => string = "";
+  [@bs.send.pipe : t] external clone : t = "";
+  /* Body.Impl */
+  [@bs.get] external body : t => readableStream = "";
+  [@bs.get] external bodyUsed : t => bool = "";
+  [@bs.send.pipe : t] external arrayBuffer : Js.Promise.t(arrayBuffer) = "";
+  [@bs.send.pipe : t] external blob : Js.Promise.t(blob) = "";
+  [@bs.send.pipe : t] external formData : Js.Promise.t(formData) = "";
+  [@bs.send.pipe : t] external json : Js.Promise.t(Js.Json.t) = "";
+  [@bs.send.pipe : t] external text : Js.Promise.t(string) = "";
+};
+
+[@bs.module "node-fetch"] external fetch : string => Js.Promise.t(response) = "default";
+
+[@bs.module "node-fetch"]
+external fetchWithInit : (string, requestInit) => Js.Promise.t(response) = "default";
+
+[@bs.module "node-fetch"]
+external fetchWithRequest : request => Js.Promise.t(response) = "default";
+
+[@bs.module "node-fetch"]
+external fetchWithRequestInit : (request, requestInit) => Js.Promise.t(response) = "default";
